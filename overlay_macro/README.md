Attribute macro for overlaying a byte/bit-level description of a struct on arbitrary byte data.

# Field Attributes

`#[overlay(...)]` on a field can provide several parameters:
`byte` - the byte at which this field resides
`bytes` - the range of bytes at which this field resides
`bits` - the range of relevant bits within the byte/byte-range

Either `byte` or `bytes` must be specified.
`bits` is optional and defaults to the entire byte range.
All are zero-based.

For arrays and struct members, bits may not be specified.

# Example

```rust
use overlay_macro::overlay;

#[overlay]
#[derive(Clone, Debug)]
pub struct InquiryCommand {
    #[overlay(byte=0, bits=0..8)]
    pub op_code: u8,

    #[overlay(byte=1)] // bits inferred from `bool` type
    pub enable_vital_product_data: bool,

    #[overlay(byte=2, bits=0..=7)] // `..=` can be used as an alternative to `..`
    pub page_code: u8,

    #[overlay(bytes=3..=4)] // if not bits are given, the whole byte range is used
    pub allocation_length: u16,
}
```

Note that attributes must be specified after `#\[overlay\]` to ensure they apply to the
generated byte-array, not the fields beforehand.

The `Debug` attribute is plucked from the `derive` attribute (if present) and implemented by
calling each property in turn, as-if the struct was a POD.

# Enums

Enum members are supported, provided they come with a `TryFrom<_>` implementation.
This can be implemented automatically by using the [`num_enum`] crate.

The primitive for the `TryFrom` comes not from the enum's `repr` attribute, but from the space
allocated to the enum in the struct, as part of the `overlay` attribute.

```rust
use overlay_macro::overlay;

#[derive(PartialEq, Eq, Debug)]
enum Transport {
    Bike, Bus, Car
}

#[overlay]
pub struct Person {
    #[overlay(byte=0, bits=1..=4)] // nothing lives at bit 0. Also 1 byte in size, so TryFrom<u8> is used
    transport: Transport,
}

impl TryFrom<u8> for Transport {
    type Error = ();

    fn try_from(v: u8) -> Result<Self, Self::Error> {
        Ok(match v {
            v if v == Self::Bike as _ => Self::Bike,
            v if v == Self::Bus  as _ => Self::Bus,
            v if v == Self::Car  as _ => Self::Car,
            _ => return Err(()),
        })
    }
}

assert_eq!(Transport::try_from(1), Ok(Transport::Bus));
```

Note that the overlay conversion may not round-trip if the `TryFrom` implementation doesn't map
the enum's entries from their actual discriminant values.

[`num_enum`]: https://crates.io/crates/num_enum

# Nested structs

Struct members are supported, and must reside on a byte-boundary.
Both the outer and inner struct must be `#[overlay]` to permit interpreting a `&[u8]` as an
instance of them.
As the macro cannot tell if a type is an `enum` or a `struct`, the `overlay` attribute must
contain `nested` to specify that this is a `struct`.

```rust
use overlay_macro::overlay;

#[overlay]
struct Inner {
    #[overlay(byte=0)]
    x: u8,

    #[overlay(bytes=1..5, bits=0..=31)]
    y: u32,
}

#[overlay]
pub struct Outer {
    #[overlay(byte=0)]
    padding: u8,

    #[overlay(bytes=1..6, nested)] // bits must not be specified for nested structs
    inner: Inner,
}

fn f(outer: &Outer) -> u32 {
    let inner: &Inner = outer.inner();

    inner.y()
}
```
